from typing import Tuple
import random
from datetime import datetime
from faker import Faker
from uuid import uuid4

from app.database.schemas.gitlab import FileContent, SAMPLE_CVSS_VECTORS
from app.database.schemas import report_base as schemas
from app.internal.report import (
    create_scanner_schema,
    create_analyzer_schema,
    create_vulnerability_schema,
    create_remediation_schema,
)


async def run(files: list[FileContent]) -> Tuple[
    bool, str, str, schemas.Scanner, schemas.Analyzer, list[schemas.Vulnerability], list[schemas.Remediation]]:
    start_time = datetime.now()

    # TODO: metadata should change according to the models we use internally
    scanner_metadata = create_scanner_schema(
        id=uuid4(),
        name="Security Vulnerability Detection LLM",
        version=":SKIP:",
        url="https://smu.edu.sg",
        vendor_name="SMU"
    )

    analyzer_metadata = create_analyzer_schema(
        id=uuid4(),
        name="SMU SCIS Vulnerability Analyzer",
        version=":SKIP:",
        url="https://smu.edu.sg",
        vendor_name="SMU"
    )

    success, vulnerabilities, remediations = await mock_scan(files=files)
    end_time = datetime.now()
    return success, start_time, end_time, scanner_metadata, analyzer_metadata, vulnerabilities, remediations


async def mock_scan(files: list[FileContent]) -> Tuple[bool, list[schemas.Vulnerability], list[schemas.Remediation]]:
    '''mock_scan simulates what happens in an actual scan. This provides the actual implementation of the model scan a rough guideline of how to call variables and what variables are necessary.
    '''
    fake = Faker()
    vulnerabilities: list[schemas.Vulnerability] = []
    for f in files:
        type_value = f"{random.randint(50, 150)}"
        vulnerabilities.append(
            create_vulnerability_schema(
                type="cwe",
                type_value=type_value,
                type_url=f"https://cwe.mitre.org/data/definitions/{type_value}.html",
                name=fake.sentence(nb_words=3),
                description=fake.sentence(nb_words=10),
                severity=random.choice(list(schemas.SeverityLevels.__args__)),
                location_file=f.path,
                location_start_line=random.randint(1, 3),
                location_end_line=random.randint(4, 6),
                cvss_vector_vector=random.choice(SAMPLE_CVSS_VECTORS),
                cvss_vector_vendor_name=f"{uuid4()}"
            )
        )

    remediations: list[schemas.Remediation] = []
    vulnerability_ids = [v.id for v in vulnerabilities]
    for _ in vulnerabilities:
        if random.choice([True, False]):  # Randomly determine if there will be a remediation for the mock scan
            remediations.append(
                create_remediation_schema(
                    vulnerability_identifiers=random.choices(vulnerability_ids),
                    # Randomly select which vulnerabilities this remediation should tackle
                    summary=fake.sentence(nb_words=10),
                    diff=fake.sentence(nb_words=10),
                )
            )

    return True, vulnerabilities, remediations


async def scan(files: list[FileContent]) -> Tuple[bool, list[schemas.Vulnerability]]:
    ...  # TODO: insert actual model scanning logic, take reference to how mock_scan above generates the relevant data
    return True

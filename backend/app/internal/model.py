from typing import Tuple
import random
from datetime import datetime
from faker import Faker
from uuid import uuid4

from app.database.schemas.gitlab import FileContent, SAMPLE_CVSS_VECTORS
from app.database.schemas import report_base as schemas
from app.internal.report import (
  create_scanner_schema,
  create_analyzer_schema,
  create_vulnerability_schema,
  create_remediation_schema,
)

async def run(files: list[FileContent]) -> Tuple[bool, str, str, schemas.Scanner, schemas.Analyzer, list[schemas.Vulnerability], list[schemas.Remediation]]:
  start_time = datetime.now()

  # TODO: metadata should change according to the models we use internally
  scanner_metadata = create_scanner_schema(
    id=uuid4(),
    name="Security Vulnerability Detection LLM",
    version=":SKIP:",
    url="https://smu.edu.sg",
    vendor_name="SMU"
  )
  
  analyzer_metadata = create_analyzer_schema(
    id=uuid4(),
    name="SMU SCIS Vulnerability Analyzer",
    version=":SKIP:",
    url="https://smu.edu.sg",
    vendor_name="SMU"
  )
  
  success, vulnerabilities, remediations = await mock_scan(files=files)
  end_time = datetime.now()
  return success, start_time, end_time, scanner_metadata, analyzer_metadata, vulnerabilities, remediations

async def mock_scan(files: list[FileContent]) -> Tuple[bool, list[schemas.Vulnerability], list[schemas.Remediation]]:
  '''mock_scan simulates what happens in an actual scan. This provides the actual implementation of the model scan a rough guideline of how to call variables and what variables are necessary.
  '''
  fake = Faker()
  vulnerabilities: list[schemas.Vulnerability] = []
  for f in files:
    type_value = f"{random.randint(50, 150)}"
    vulnerabilities.append(
      create_vulnerability_schema(
        type="cwe",
        type_value=type_value,
        type_url=f"https://cwe.mitre.org/data/definitions/{type_value}.html",
        name=fake.sentence(nb_words=3),
        description=fake.sentence(nb_words=10),
        severity=random.choice(list(schemas.SeverityLevels.__args__)),
        location_file=f.path,
        location_start_line=random.randint(1, 3),
        location_end_line=random.randint(4, 6),
        cvss_vector_vector=random.choice(SAMPLE_CVSS_VECTORS),
        cvss_vector_vendor_name=f"{uuid4()}"
      )
    )

  remediations: list[schemas.Remediation] = []
  vulnerability_ids = [v.id for v in vulnerabilities]
  for _ in vulnerabilities:
    if random.choice([True, False]): # Randomly determine if there will be a remediation for the mock scan
      remediations.append(
        create_remediation_schema(
          vulnerability_identifiers=random.choices(vulnerability_ids), # Randomly select which vulnerabilities this remediation should tackle
          summary=fake.sentence(nb_words=10),
          diff=fake.sentence(nb_words=10),
        )
      )

  return True, vulnerabilities, remediations

async def scan(files: list[FileContent]) -> Tuple[bool, list[schemas.Vulnerability]]:
  ... # TODO: insert actual model scanning logic, take reference to how mock_scan above generates the relevant data
  return True
from typing import Optional, Tuple
import aiohttp
import asyncio
from urllib.parse import quote
from starlette.status import HTTP_200_OK

from app.config.app import settings
from app.database.schemas.gitlab import FileContent

class STAGES:
  VULNERABILITY_SCAN = "vulnerability-scan-job"
  REPORT_RETRIEVAL = "report-retrieval-job"

async def get_related_files(gl_project_id: str, gl_commit_sha: str, diff: list[str]) -> Tuple[bool, Optional[list[FileContent]]]:
  async with aiohttp.ClientSession() as session:
    files: list[FileContent] = []
    
    for file_path in diff:
      encoded_file_path = quote(file_path, safe='')
      api_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/repository/files/{encoded_file_path}/raw?ref={gl_commit_sha}"
      headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}

      async with session.get(api_url, headers=headers) as response:
        if response.status == HTTP_200_OK:
          content = await response.read()
          files.append(FileContent(path=file_path, content=content))
        else:
          return False, None
    return True, files

async def retrieve_latest_job(gl_project_id: str, gl_pipeline_id:str, gl_job_id: str) -> Tuple[bool, Optional[str]]:
  async with aiohttp.ClientSession() as session:
    api_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/pipelines/{gl_pipeline_id}/jobs"
    headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}
    async with session.get(api_url, headers=headers) as response:
      if response.status != HTTP_200_OK:
        return False, None
      
      jobs_data = await response.json()
      for job_data in jobs_data:
        if job_data["name"] == STAGES.REPORT_RETRIEVAL:
          return True, str(job_data["id"])
  return False, None

async def run_artifact_retrieval_job(gl_project_id: str, gl_job_id: str) -> bool:
  async with aiohttp.ClientSession() as session:
    api_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/jobs/{gl_job_id}/play"
    headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}
    async with aiohttp.ClientSession() as session:
      async with session.post(api_url, headers=headers) as response:
        if response.status != HTTP_200_OK:
          return False
        return True
  return False

async def trigger_job(gl_project_id: str, gl_pipeline_id: str, gl_job_id:str) -> bool:
  success, target_job_id = await retrieve_latest_job(
    gl_project_id=gl_project_id,
    gl_pipeline_id=gl_pipeline_id,
    gl_job_id=gl_job_id
  )
  if not success:
    return False
  await asyncio.sleep(10) # Async time block to allow GitLab servers to initialise `report_retrieval_job` if internal process completes too fast
  return await run_artifact_retrieval_job(gl_project_id=gl_project_id, gl_job_id=target_job_id)
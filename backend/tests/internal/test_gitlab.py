import pytest
from unittest.mock import patch
import asyncio
from aioresponses import aioresponses
from faker import Faker
from urllib.parse import quote

from app.config.app import settings
from app.internal.gitlab import (
    STAGES,
    get_related_files,
    retrieve_latest_job,
    run_artifact_retrieval_job,
    trigger_job,
)
from app.database.schemas.gitlab import FileContent


@pytest.mark.asyncio
async def test_get_related_files_success(mock_aioresponse: aioresponses):
    fake = Faker()
    gl_project_id = fake.random_number(digits=5)
    gl_commit_sha = fake.sha1()
    diff = [fake.file_path() for _ in range(5)]
    files: list[FileContent] = [
        FileContent(path=file_path, content=fake.sentence(nb_words=10).encode('utf-8')) for file_path in diff
    ]
    headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}

    for data in files:
        encoded_file_path = quote(data.path, safe='')
        api_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/repository/files/{encoded_file_path}/raw?ref={gl_commit_sha}"
        mock_aioresponse.get(
            api_url,
            headers=headers,
            status=200,
            body=data.content
        )

    success, response_files = await get_related_files(gl_project_id, gl_commit_sha, diff)
    assert success
    assert len(response_files) == 5
    for data, response_data in zip(files, response_files):
        assert data.path == response_data.path
        assert data.content == response_data.content


@pytest.mark.asyncio
async def test_get_related_files_failure(mock_aioresponse: aioresponses):
    fake = Faker()
    gl_project_id = fake.random_number(digits=5)
    gl_commit_sha = fake.sha1()
    diff = [fake.file_path() for _ in range(5)]
    files: list[FileContent] = [
        FileContent(path=file_path, content=fake.sentence(nb_words=10).encode('utf-8')) for file_path in diff
    ]
    headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}

    for data in files:
        encoded_file_path = quote(data.path, safe='')
        api_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/repository/files/{encoded_file_path}/raw?ref={gl_commit_sha}"
        mock_aioresponse.get(
            api_url,
            headers=headers,
            status=400,
            body=data.content
        )

    success, response_files = await get_related_files(gl_project_id, gl_commit_sha, diff)
    assert not success
    assert response_files is None


@pytest.mark.asyncio
async def test_retrieve_latest_job_success(mock_aioresponse: aioresponses):
    fake = Faker()
    gl_project_id = fake.random_number(digits=5)
    gl_pipeline_id = fake.random_number(digits=5)
    gl_job_id = fake.random_number(digits=5)
    new_job_id = fake.random_int()

    api_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/pipelines/{gl_pipeline_id}/jobs"
    headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}
    mock_aioresponse.get(
        api_url,
        headers=headers,
        status=200,
        payload=[
            {"name": STAGES.VULNERABILITY_SCAN, "id": fake.random_int()},
            {"name": STAGES.REPORT_RETRIEVAL, "id": new_job_id},
        ]
    )

    success, target_job_id = await retrieve_latest_job(gl_project_id, gl_pipeline_id, gl_job_id)

    assert success
    assert target_job_id == str(new_job_id)


@pytest.mark.asyncio
async def test_retrieve_latest_job_no_match(mock_aioresponse: aioresponses):
    fake = Faker()
    gl_project_id = fake.random_number(digits=5)
    gl_pipeline_id = fake.random_number(digits=5)
    gl_job_id = fake.random_number(digits=5)
    db_job_id = fake.random_int()

    api_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/pipelines/{gl_pipeline_id}/jobs"
    headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}
    mock_aioresponse.get(
        api_url,
        headers=headers,
        status=200,
        payload=[
            {"name": STAGES.VULNERABILITY_SCAN, "id": fake.random_int()},
        ]
    )

    success, target_job_id = await retrieve_latest_job(gl_project_id, gl_pipeline_id, gl_job_id)

    assert not success
    assert target_job_id is None


@pytest.mark.asyncio
async def test_retrieve_latest_job_failure(mock_aioresponse: aioresponses):
    fake = Faker()
    gl_project_id = fake.random_number(digits=5)
    gl_pipeline_id = fake.random_number(digits=5)
    gl_job_id = fake.random_number(digits=5)

    api_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/pipelines/{gl_pipeline_id}/jobs"
    headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}
    mock_aioresponse.get(api_url, headers=headers, status=404)

    success, target_job_id = await retrieve_latest_job(gl_project_id, gl_pipeline_id, gl_job_id)

    assert not success
    assert target_job_id is None


@pytest.mark.asyncio
async def test_run_artifact_retrieval_job_success(mock_aioresponse: aioresponses):
    fake = Faker()
    gl_project_id = fake.random_number(digits=5)
    gl_job_id = fake.random_number(digits=5)

    api_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/jobs/{gl_job_id}/play"
    headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}
    mock_aioresponse.post(api_url, headers=headers, status=200)

    success = await run_artifact_retrieval_job(gl_project_id, gl_job_id)
    assert success


@pytest.mark.asyncio
async def test_run_artifact_retrieval_job_failure(mock_aioresponse: aioresponses):
    fake = Faker()
    gl_project_id = fake.random_number(digits=5)
    gl_job_id = fake.random_number(digits=5)

    api_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/jobs/{gl_job_id}/play"
    headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}
    mock_aioresponse.post(api_url, headers=headers, status=500)

    success = await run_artifact_retrieval_job(gl_project_id, gl_job_id)
    assert not success


@pytest.mark.asyncio
async def test_trigger_job_success(mock_aioresponse: aioresponses):
    fake = Faker()
    gl_project_id = fake.random_number(digits=5)
    gl_pipeline_id = fake.random_number(digits=5)
    gl_job_id = fake.random_number(digits=5)
    new_job_id = fake.random_int()

    headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}
    job_retrieval_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/pipelines/{gl_pipeline_id}/jobs"
    mock_aioresponse.get(
        job_retrieval_url,
        headers=headers,
        status=200,
        payload=[
            {"name": STAGES.VULNERABILITY_SCAN, "id": fake.random_int()},
            {"name": STAGES.REPORT_RETRIEVAL, "id": new_job_id},
        ])

    artifact_retrieval_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/jobs/{new_job_id}/play"
    mock_aioresponse.post(
        artifact_retrieval_url,
        headers=headers,
        status=200
    )
    with patch('asyncio.sleep', return_value=asyncio.Future()) as mock_sleep:
        success = await trigger_job(gl_project_id, gl_pipeline_id, gl_job_id)
    assert success


@pytest.mark.asyncio
async def test_trigger_job_job_retrieval_failure(mock_aioresponse: aioresponses):
    fake = Faker()
    gl_project_id = fake.random_number(digits=5)
    gl_pipeline_id = fake.random_number(digits=5)
    gl_job_id = fake.random_number(digits=5)

    job_retrieval_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/pipelines/{gl_pipeline_id}/jobs"
    headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}
    mock_aioresponse.get(
        job_retrieval_url,
        headers=headers,
        status=200,
        payload=[
            {"name": STAGES.VULNERABILITY_SCAN, "id": fake.random_int()},
        ]
    )

    success = await trigger_job(gl_project_id, gl_pipeline_id, gl_job_id)
    assert not success


@pytest.mark.asyncio
async def test_trigger_job_artifact_retrieval_failure(mock_aioresponse: aioresponses):
    fake = Faker()
    gl_project_id = fake.random_number(digits=5)
    gl_pipeline_id = fake.random_number(digits=5)
    gl_job_id = fake.random_number(digits=5)
    new_job_id = fake.random_int()

    headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}
    job_retrieval_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/pipelines/{gl_pipeline_id}/jobs"
    mock_aioresponse.get(
        job_retrieval_url,
        headers=headers,
        status=200,
        payload=[
            {"name": STAGES.VULNERABILITY_SCAN, "id": fake.random_int()},
            {"name": STAGES.REPORT_RETRIEVAL, "id": new_job_id},
        ])

    artifact_retrieval_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/jobs/{new_job_id}/play"
    mock_aioresponse.post(
        artifact_retrieval_url,
        headers=headers,
        status=500
    )
    with patch('asyncio.sleep', return_value=asyncio.Future()) as mock_sleep:
        success = await trigger_job(gl_project_id, gl_pipeline_id, gl_job_id)
    assert not success

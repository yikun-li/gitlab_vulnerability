import pytest
from unittest.mock import patch
import asyncio
from aioresponses import aioresponses
from faker import Faker
from urllib.parse import quote

from app.config.app import settings
from app.internal.gitlab import (
  STAGES,
  get_related_files,
  retrieve_latest_job,
  run_artifact_retrieval_job,
  trigger_job,
)
from app.database.schemas.gitlab import FileContent

@pytest.mark.asyncio
async def test_get_related_files_success(mock_aioresponse: aioresponses):
  fake = Faker()
  gl_project_id = fake.random_number(digits=5)
  gl_commit_sha = fake.sha1()
  diff = [fake.file_path() for _ in range(5)]
  files: list[FileContent] = [
    FileContent(path=file_path, content=fake.sentence(nb_words=10).encode('utf-8')) for file_path in diff
  ]
  headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}

  for data in files:
    encoded_file_path = quote(data.path, safe='')
    api_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/repository/files/{encoded_file_path}/raw?ref={gl_commit_sha}"
    mock_aioresponse.get(
      api_url,
      headers=headers,
      status=200,
      body=data.content
    )

  success, response_files = await get_related_files(gl_project_id, gl_commit_sha, diff)
  assert success
  assert len(response_files) == 5
  for data, response_data in zip(files, response_files):
    assert data.path == response_data.path
    assert data.content == response_data.content

@pytest.mark.asyncio
async def test_get_related_files_failure(mock_aioresponse: aioresponses):
  fake = Faker()
  gl_project_id = fake.random_number(digits=5)
  gl_commit_sha = fake.sha1()
  diff = [fake.file_path() for _ in range(5)]
  files: list[FileContent] = [
    FileContent(path=file_path, content=fake.sentence(nb_words=10).encode('utf-8')) for file_path in diff
  ]
  headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}

  for data in files:
    encoded_file_path = quote(data.path, safe='')
    api_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/repository/files/{encoded_file_path}/raw?ref={gl_commit_sha}"
    mock_aioresponse.get(
      api_url,
      headers=headers,
      status=400,
      body=data.content
    )

  success, response_files = await get_related_files(gl_project_id, gl_commit_sha, diff)
  assert not success
  assert response_files is None

@pytest.mark.asyncio
async def test_retrieve_latest_job_success(mock_aioresponse: aioresponses):
  fake = Faker()    
  gl_project_id = fake.random_number(digits=5)
  gl_pipeline_id = fake.random_number(digits=5)
  gl_job_id = fake.random_number(digits=5)
  new_job_id = fake.random_int()

  api_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/pipelines/{gl_pipeline_id}/jobs"
  headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}
  mock_aioresponse.get(
    api_url, 
    headers=headers,
    status=200,
    payload=[
      {"name": STAGES.VULNERABILITY_SCAN, "id": fake.random_int()},
      {"name": STAGES.REPORT_RETRIEVAL, "id": new_job_id},
    ]
  )

  success, target_job_id = await retrieve_latest_job(gl_project_id, gl_pipeline_id, gl_job_id)

  assert success
  assert target_job_id == str(new_job_id)

@pytest.mark.asyncio
async def test_retrieve_latest_job_no_match(mock_aioresponse: aioresponses):
  fake = Faker()    
  gl_project_id = fake.random_number(digits=5)
  gl_pipeline_id = fake.random_number(digits=5)
  gl_job_id = fake.random_number(digits=5)
  db_job_id = fake.random_int()

  api_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/pipelines/{gl_pipeline_id}/jobs"
  headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}
  mock_aioresponse.get(
    api_url, 
    headers=headers,
    status=200,
    payload=[
      {"name": STAGES.VULNERABILITY_SCAN, "id": fake.random_int()},
    ]
  )

  success, target_job_id = await retrieve_latest_job(gl_project_id, gl_pipeline_id, gl_job_id)

  assert not success
  assert target_job_id is None

@pytest.mark.asyncio
async def test_retrieve_latest_job_failure(mock_aioresponse: aioresponses):
  fake = Faker()    
  gl_project_id = fake.random_number(digits=5)
  gl_pipeline_id = fake.random_number(digits=5)
  gl_job_id = fake.random_number(digits=5)

  api_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/pipelines/{gl_pipeline_id}/jobs"
  headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}
  mock_aioresponse.get(api_url, headers=headers, status=404)

  success, target_job_id = await retrieve_latest_job(gl_project_id, gl_pipeline_id, gl_job_id)

  assert not success
  assert target_job_id is None

@pytest.mark.asyncio
async def test_run_artifact_retrieval_job_success(mock_aioresponse: aioresponses):
  fake = Faker()    
  gl_project_id = fake.random_number(digits=5)
  gl_job_id = fake.random_number(digits=5)

  api_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/jobs/{gl_job_id}/play"
  headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}
  mock_aioresponse.post(api_url, headers=headers, status=200)

  success = await run_artifact_retrieval_job(gl_project_id, gl_job_id)
  assert success

@pytest.mark.asyncio
async def test_run_artifact_retrieval_job_failure(mock_aioresponse: aioresponses):
  fake = Faker()    
  gl_project_id = fake.random_number(digits=5)
  gl_job_id = fake.random_number(digits=5)

  api_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/jobs/{gl_job_id}/play"
  headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}
  mock_aioresponse.post(api_url, headers=headers, status=500)

  success = await run_artifact_retrieval_job(gl_project_id, gl_job_id)
  assert not success

@pytest.mark.asyncio
async def test_trigger_job_success(mock_aioresponse: aioresponses):
  fake = Faker()
  gl_project_id = fake.random_number(digits=5)
  gl_pipeline_id = fake.random_number(digits=5)
  gl_job_id = fake.random_number(digits=5)
  new_job_id = fake.random_int()

  headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}
  job_retrieval_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/pipelines/{gl_pipeline_id}/jobs"
  mock_aioresponse.get(
    job_retrieval_url,
    headers=headers,
    status=200,
    payload=[
      {"name": STAGES.VULNERABILITY_SCAN, "id": fake.random_int()},
      {"name": STAGES.REPORT_RETRIEVAL, "id": new_job_id},
    ])

  artifact_retrieval_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/jobs/{new_job_id}/play"
  mock_aioresponse.post(
    artifact_retrieval_url,
    headers=headers,
    status=200
  )
  with patch('asyncio.sleep', return_value=asyncio.Future()) as mock_sleep:
    success = await trigger_job(gl_project_id, gl_pipeline_id, gl_job_id)
  assert success

@pytest.mark.asyncio
async def test_trigger_job_job_retrieval_failure(mock_aioresponse: aioresponses):
  fake = Faker()
  gl_project_id = fake.random_number(digits=5)
  gl_pipeline_id = fake.random_number(digits=5)
  gl_job_id = fake.random_number(digits=5)

  job_retrieval_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/pipelines/{gl_pipeline_id}/jobs"
  headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}
  mock_aioresponse.get(
    job_retrieval_url, 
    headers=headers,
    status=200,
    payload=[
      {"name": STAGES.VULNERABILITY_SCAN, "id": fake.random_int()},
    ]
  )

  success = await trigger_job(gl_project_id, gl_pipeline_id, gl_job_id)
  assert not success

@pytest.mark.asyncio
async def test_trigger_job_artifact_retrieval_failure(mock_aioresponse: aioresponses):
  fake = Faker()
  gl_project_id = fake.random_number(digits=5)
  gl_pipeline_id = fake.random_number(digits=5)
  gl_job_id = fake.random_number(digits=5)
  new_job_id = fake.random_int()

  headers = {"Authorization": f'Bearer {settings.GITLAB_ACCESS_TOKEN}'}
  job_retrieval_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/pipelines/{gl_pipeline_id}/jobs"
  mock_aioresponse.get(
    job_retrieval_url,
    headers=headers,
    status=200,
    payload=[
      {"name": STAGES.VULNERABILITY_SCAN, "id": fake.random_int()},
      {"name": STAGES.REPORT_RETRIEVAL, "id": new_job_id},
    ])

  artifact_retrieval_url = f"{settings.GITLAB_BASE_API_URL}/{gl_project_id}/jobs/{new_job_id}/play"
  mock_aioresponse.post(
    artifact_retrieval_url,
    headers=headers,
    status=500
  )
  with patch('asyncio.sleep', return_value=asyncio.Future()) as mock_sleep:
    success = await trigger_job(gl_project_id, gl_pipeline_id, gl_job_id)
  assert not success
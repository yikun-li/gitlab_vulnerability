from faker import Faker
from random import randint
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session
from starlette.status import (
    HTTP_200_OK,
    HTTP_202_ACCEPTED,
)
from unittest.mock import AsyncMock
from pytest_mock import MockerFixture

from app.config.app import settings
from app.routers.detection import DETECTION_API_PREFIX
from app.workers import scan_job

from tests.factories.detection import JobFactory
from tests.utils.assertion import assert_attributes


def test_start(client: TestClient, mocker: MockerFixture) -> None:
    test_endpoint = f"{settings.API_VERSION_PREFIX}{DETECTION_API_PREFIX}/start"
    fake = Faker()
    data = {
        "gl_project_dir": f"{fake.file_path()}",
        "gl_commit_sha": f"{fake.sha1()}",
        "gl_project_id": f"{fake.random_number(digits=5)}",
        "gl_pipeline_id": f"{fake.random_number(digits=5)}",
        "gl_job_id": f"{fake.random_number(digits=5)}",
        "diff": [f'{fake.file_path()}' for _ in range(randint(1, 10))]
    }

    mock_scan_job_start = mocker.patch.object(scan_job, "start", new_callable=AsyncMock)

    response = client.post(
        test_endpoint,
        json=data
    )
    assert response.status_code == HTTP_202_ACCEPTED
    content = response.json()
    assert "id" in content
    assert_attributes(db_object=content, attrs=data)
    mock_scan_job_start.assert_called_once_with(content["id"])


def test_get_job(client: TestClient) -> None:
    job = JobFactory()
    test_endpoint = f"{settings.API_VERSION_PREFIX}{DETECTION_API_PREFIX}/get_by_gl_job_id/{job.gl_job_id}"
    response = client.get(
        test_endpoint
    )
    content = response.json()
    assert response.status_code == HTTP_200_OK
    assert_attributes(db_object=job, attrs=content)

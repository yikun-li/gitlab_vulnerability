from faker import Faker
from random import randint
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session
from starlette.status import (
  HTTP_200_OK,
  HTTP_202_ACCEPTED,
)
from unittest.mock import AsyncMock
from pytest_mock import MockerFixture

from app.config.app import settings
from app.routers.detection import DETECTION_API_PREFIX
from app.workers import scan_job

from tests.factories.detection import JobFactory
from tests.utils.assertion import assert_attributes

def test_start(client: TestClient, mocker: MockerFixture) -> None:
  test_endpoint = f"{settings.API_VERSION_PREFIX}{DETECTION_API_PREFIX}/start"
  fake = Faker()
  data = {
    "gl_project_dir": f"{fake.file_path()}",
    "gl_commit_sha": f"{fake.sha1()}",
    "gl_project_id": f"{fake.random_number(digits=5)}",
    "gl_pipeline_id": f"{fake.random_number(digits=5)}",
    "gl_job_id": f"{fake.random_number(digits=5)}",
    "diff": [f'{fake.file_path()}' for _ in range(randint(1, 10))]
  }

  mock_scan_job_start = mocker.patch.object(scan_job, "start", new_callable=AsyncMock)

  response = client.post(
    test_endpoint,
    json=data
  )
  assert response.status_code == HTTP_202_ACCEPTED
  content = response.json()
  assert "id" in content
  assert_attributes(db_object=content, attrs=data)
  mock_scan_job_start.assert_called_once_with(content["id"])

def test_get_job(client: TestClient) -> None:
  job = JobFactory()
  test_endpoint = f"{settings.API_VERSION_PREFIX}{DETECTION_API_PREFIX}/get_by_gl_job_id/{job.gl_job_id}"
  response = client.get(
    test_endpoint
  )
  content = response.json()
  assert response.status_code == HTTP_200_OK
  assert_attributes(db_object=job, attrs=content)

import random
from datetime import datetime, timedelta
from factory import (
  SubFactory,
  lazy_attribute,
  LazyFunction,
  List as factory_list,
  Trait,
  post_generation
)
from factory.alchemy import SQLAlchemyModelFactory
from factory.faker import Faker

from app.database.models import report as models
from app.database.schemas import report_base as schemas

from tests.factories.detection import JobFactory

class CommunicationFactory(SQLAlchemyModelFactory):
  class Meta:
    model = models.Communication
    sqlalchemy_session_persistence = "commit"
  
  level = random.choice(schemas.CommunicationLevels.__args__)
  value = Faker("sentence", nb_words=10)

class ConfigurationOptionFactory(SQLAlchemyModelFactory):
  class Meta:
    model = models.ConfigurationOption
    sqlalchemy_session_persistence = "commit"

  name = Faker("name")
  source = random.choice(schemas.ConfigSources.__args__)
  
  @lazy_attribute
  def value(self):
    return f"{random.uniform(0, 1)}"

class VendorFactory(SQLAlchemyModelFactory):
  class Meta:
    model = models.Vendor
    sqlalchemy_session_persistence = "commit"
  
  name = Faker("uuid4") # To get a unique "name" for each test

class AnalyzerFactory(SQLAlchemyModelFactory):
  class Meta:
    model = models.Analyzer
    sqlalchemy_session_persistence = "commit"
  
  id = Faker("uuid4")
  name = Faker("name")
  url = Faker("url")
  vendor = SubFactory(VendorFactory)
  
  @lazy_attribute
  def version(self):
    return f"{random.uniform(0, 10)}"

class ScannerFactory(SQLAlchemyModelFactory):
  class Meta:
    model = models.Scanner
    sqlalchemy_session_persistence = "commit"  

  id = Faker("uuid4")
  name = Faker("name")
  url = Faker("url")
  vendor = SubFactory(VendorFactory)

  name = Faker("name")
  @lazy_attribute
  def version(self):
    return f"{random.uniform(0, 10)}"

class IdentifierFactory(SQLAlchemyModelFactory):
  class Meta:
    model = models.Identifier
    sqlalchemy_session_persistence = "commit"
  
  type = Faker("name")
  name = Faker("name")
  value = f"{Faker('random_number', digits=3)}"
  url = Faker("url")

class CVSSVectorFactory(SQLAlchemyModelFactory):
  class Meta:
    model = models.CVSSVector
    sqlalchemy_session_persistence = "commit"
  
  vector = Faker("name")
  vendor = SubFactory(VendorFactory)
  
  @lazy_attribute
  def vendor_name(self):
    return self.vendor.name

class LinkFactory(SQLAlchemyModelFactory):
  class Meta:
    model = models.Link
    sqlalchemy_session_persistence = "commit"
  
  url = Faker("url")
  name = Faker("name")

class LocationFactory(SQLAlchemyModelFactory):
  class Meta:
    model = models.Location
    sqlalchemy_session_persistence = "commit"

  file = Faker("file_name")
  class_name = Faker("first_name")
  method_name = Faker("last_name")
  
  @lazy_attribute
  def start_line(self):
    return random.randint(1, 5)
  
  @lazy_attribute
  def end_line(self):
    return random.randint(5, 10)
  
class FlagFactory(SQLAlchemyModelFactory):
  class Meta:
    model = models.Flag
    sqlalchemy_session_persistence = "commit"

  type = random.choice(schemas.FlagTypes.__args__)
  origin = Faker("name")
  description = Faker("sentence", nb_words=10)

class VulnerabilityFactory(SQLAlchemyModelFactory):
  class Meta:
    model = models.Vulnerability
    sqlalchemy_session_persistence = "commit"

  id = Faker("uuid4")
  name = Faker("name")
  description = Faker("sentence", nb_words=10)
  severity = random.choice(schemas.SeverityLevels.__args__)
  raw_source_code_extract = Faker("sentence")

  identifiers = factory_list([SubFactory(IdentifierFactory) for _ in range(3)])
  links = factory_list([SubFactory(LinkFactory) for _ in range(3)])
  location = SubFactory(LocationFactory)
  flags = factory_list([SubFactory(FlagFactory) for _ in range (3)])
  cvss_vectors = factory_list([SubFactory(CVSSVectorFactory) for _ in range(5)])

class ScanFactory(SQLAlchemyModelFactory):
  class Meta:
    model = models.Scan
    sqlalchemy_session_persistence = "commit"

  start_time = LazyFunction(datetime.now)
  status = "success"
  type = "sast"

  @lazy_attribute
  def end_time(self):
    return self.start_time + timedelta(minutes=random.uniform(0, 10))
  
  class Params:
    dependencies_furnished = Trait(
      scanner = SubFactory(ScannerFactory),
      analyzer = SubFactory(AnalyzerFactory)
    )
  
class RemediationFactory(SQLAlchemyModelFactory):
  class Meta:
    model = models.Remediation
    sqlalchemy_session_persistence = "commit"

  summary = Faker("sentence", nb_words=10)
  diff = Faker("sentence")
  
class VulnerabilityIdentifierFactory(SQLAlchemyModelFactory):
  class Meta:
    model = models.VulnerabilityIdentifier
    sqlalchemy_session_persistence = "commit"
    
  vulnerability = SubFactory(VulnerabilityFactory)
  remediation = SubFactory(RemediationFactory)

class SecurityReportFactory(SQLAlchemyModelFactory):
  class Meta:
    model = models.SecurityReport
    sqlalchemy_session_persistence = "commit"
  
  job = SubFactory(JobFactory)
  scan = SubFactory(ScanFactory, dependencies_furnished=True)

  @post_generation
  def vulnerabilities_and_remediations(self, create, extracted, **kwargs):
    if not create:
      return
    
    if extracted:
      self.vulnerabilities = [vi.vulnerability for vi in extracted]
      self.remediations = [vi.remediation for vi in extracted]
    else:
      vi_list = [VulnerabilityIdentifierFactory() for _ in range(5)]
      self.vulnerabilities = [vi.vulnerability for vi in vi_list]
      self.remediations = [vi.remediation for vi in vi_list]